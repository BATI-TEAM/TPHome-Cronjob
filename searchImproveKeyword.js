const { chromium } = require('playwright');

let isRunning = false;
let isFirstRun = true;

const keywords = ["gi√° g·∫°ch 40x40", "g·∫°ch stile", "g·∫°ch ·ªëp vi·ªÅn"];

// L·∫•y hrefs an to√†n
async function safeGetHrefs(page, selector, retries = 3) {
  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      await page.waitForSelector(selector, { timeout: 4000 }).catch(() => { });
      const locators = await page.locator(selector).all();
      const hrefs = [];
      for (const loc of locators) {
        try {
          let href = await loc.getAttribute('href');
          if (!href) continue;
          // Gi·∫£i m√£ redirect c·ªßa Google
          if (href.startsWith('/url?') || href.includes('/url?q=')) {
            try {
              const u = new URL(href, 'https://www.google.com');
              const q = u.searchParams.get('q');
              if (q) href = q;
            } catch { }
          }
          hrefs.push(href);
        } catch { }
      }
      return [...new Set(hrefs)];
    } catch (err) {
      console.warn(`safeGetHrefs: attempt ${attempt} failed: ${err?.message || err}`);
      if (attempt < retries) {
        await page.waitForTimeout(800);
        continue;
      } else {
        throw err;
      }
    }
  }
  return [];
}

// Click an to√†n: h·ªó tr·ª£ popup (target=_blank) ho·∫∑c ƒëi·ªÅu h∆∞·ªõng c√πng tab
async function safeClick(page, locator, timeout = 15000) {
  try {
    const popupPromise = page.waitForEvent('popup', { timeout }).catch(() => null);
    const navPromise = page.waitForNavigation({ waitUntil: 'domcontentloaded', timeout }).catch(() => null);
    await locator.click({ timeout });
    const popup = await popupPromise;
    const nav = await navPromise;

    if (popup) {
      await popup.waitForLoadState('domcontentloaded', { timeout }).catch(() => { });
      return { page: popup, isPopup: true };
    }

    // N·∫øu kh√¥ng c√≥ popup, v·∫´n ƒë·ª£i loadState (ph√≤ng SPA kh√¥ng fire navigation)
    await page.waitForLoadState('domcontentloaded', { timeout }).catch(() => { });
    return { page, isPopup: false };
  } catch (e) {
    console.log('‚ö† safeClick error:', e?.message || e);
    return { page, isPopup: false, error: e };
  }
}

// Click link theo URL trong trang hi·ªán t·∫°i; n·∫øu fail th√¨ th·ª≠ link kh√°c trong danh s√°ch
async function clickLinkByUrl(page, url, candidates = [], timeout = 15000) {
  try {
    const u = new URL(url);
    const host = u.hostname;
    const path = u.pathname.replace(/\/+$/, "");
    const lastSeg = path.split('/').filter(Boolean).pop() || '';

    // ∆Øu ti√™n t√¨m ch√≠nh x√°c link t·ªõi url
    let link = page.locator(`a[href="${url}"]:visible`).first();
    if (!(await link.count())) link = page.locator(`a[href$="${path}"]:visible`).first();
    if (!(await link.count())) {
      link = lastSeg
        ? page.locator(`a[href*="${host}"][href*="${lastSeg}"]:visible`).first()
        : page.locator(`a[href*="${host}"]:visible`).first();
    }

    if (await link.count()) {
      const res = await safeClick(page, link, timeout);
      return res.page;
    }

    // N·∫øu kh√¥ng t√¨m th·∫•y link t·ªõi URL n√†y ‚Üí th·ª≠ candidates kh√°c
    for (const candidate of candidates) {
      try {
        let candLink = page.locator(`a[href="${candidate}"]:visible`).first();
        if (!(await candLink.count())) candLink = page.locator(`a[href*="${candidate}"]:visible`).first();

        if (await candLink.count()) {
          console.log(`üëâ Kh√¥ng t√¨m th·∫•y link ${url}, th·ª≠ link kh√°c: ${candidate}`);
          const res = await safeClick(page, candLink, timeout);
          return res.page;
        }
      } catch { }
    }

    // N·∫øu to√†n b·ªô candidates ƒë·ªÅu kh√¥ng click ƒë∆∞·ª£c ‚Üí fallback goto
    console.log(`‚ö† Kh√¥ng t√¨m th·∫•y link h·ª£p l·ªá n√†o, fallback goto: ${url}`);
    await page.goto(url, { waitUntil: 'domcontentloaded', timeout }).catch(() => { });
    return page;
  } catch (e) {
    console.log('‚ö† clickLinkByUrl error, fallback goto:', e?.message || e);
    await page.goto(url, { waitUntil: 'domcontentloaded' }).catch(() => { });
    return page;
  }
}

// X·ª≠ l√Ω khi ƒë√£ v√†o (ho·∫∑c ƒëi·ªÅu h∆∞·ªõng v√†o) site tphomevn
async function handleTphomevnPage(activePage, startUrl) {
  console.log(`üåê T·ªõi tphomevn: ${startUrl}`);

  if (!activePage.url().includes('tphomevn.com')) {
    activePage = await clickLinkByUrl(activePage, startUrl);
  }
  console.log(`‚úÖ ƒêang ·ªü: ${activePage.url()}`);

  // Ch·ªù 20s ·ªü trang ƒë·∫ßu ti√™n
  console.log('‚è≥ ƒê·ª£i 20s trong trang tphomevn...');
  await activePage.waitForTimeout(20000);

  // L·∫•y c√°c link n·ªôi b·ªô
  const allHrefs = await safeGetHrefs(activePage, 'a[href]').catch(() => []);
  let internalLinks = [];
  for (let href of allHrefs) {
    if (!href) continue;
    if (href.startsWith('/')) {
      try { href = new URL(href, activePage.url()).href; } catch { }
    }
    if (
      href.includes('tphomevn.com') &&
      !href.startsWith('mailto:') &&
      !href.startsWith('tel:') &&
      !href.includes('facebook.com') &&
      !href.includes('instagram.com') &&
      href !== startUrl
    ) {
      internalLinks.push(href);
    }
  }

  internalLinks = [...new Set(internalLinks)]; // lo·∫°i tr√πng

  if (internalLinks.length > 0) {
    // Random s·ªë l·∫ßn click: 3 ho·∫∑c 4
    const clickCount = 3 + Math.floor(Math.random() * 2);

    console.log(`üéØ S·∫Ω click ${clickCount} link ng·∫´u nhi√™n trong site`);

    for (let i = 0; i < clickCount && internalLinks.length > 0; i++) {
      const randomIndex = Math.floor(Math.random() * internalLinks.length);
      const chosen = internalLinks.splice(randomIndex, 1)[0]; // l·∫•y ra v√† xo√° kh·ªèi danh s√°ch

      console.log(`üîó Click ${i + 1}/${clickCount}: ${chosen}`);

      const afterClickPage = await clickLinkByUrl(activePage, chosen, internalLinks);
      console.log(`üåç ƒê√£ v√†o: ${afterClickPage.url()}`);

      // D·ª´ng ng·∫´u nhi√™n 15‚Äì20s
      const delay = 15000 + Math.floor(Math.random() * 5000);
      console.log(`‚è≥ ƒê·ª£i ${Math.round(delay / 1000)}s trong trang con...`);
      await afterClickPage.waitForTimeout(delay);

      activePage = afterClickPage; // ti·∫øp t·ª•c click t·ª´ trang m·ªõi
    }
  } else {
    console.log('‚ö† Kh√¥ng t√¨m th·∫•y link n·ªôi b·ªô h·ª£p l·ªá sau filter.');
  }
}

async function runGoogleSearchAndNavigate() {
  if (isRunning) {
    console.log('M·ªôt ti·∫øn tr√¨nh ƒëang ch·∫°y, b·ªè qua.');
    return;
  }
  isRunning = true;

  let browser;
  try {
    browser = await chromium.launch({ headless: false });
    const page = await browser.newPage();

    let keywordIndex = 0;

    while (true) {
      const keyword = keywords[keywordIndex];
      console.log(`\nüîç T√¨m v·ªõi t·ª´ kho√°: "${keyword}" (index ${keywordIndex})`);

      await page.goto('https://www.google.com', { waitUntil: 'domcontentloaded' });
      try {
        await page.fill('[name="q"]', keyword);
      } catch {
        try { await page.fill('textarea[name="q"]', keyword); } catch { }
      }
      await Promise.all([
        page.keyboard.press('Enter'),
        page.waitForNavigation({ waitUntil: 'domcontentloaded', timeout: 10000 }).catch(() => { })
      ]);

      // Sau khi search keyword xong v√† load k·∫øt qu·∫£
      if (page.url().includes("/sorry/index")) {
        console.log("üö® Google block (sorry/index) -> ƒë·ª£i 30s r·ªìi retry...");
        await page.waitForTimeout(30000);
        continue; // b·ªè qua v√≤ng while n√†y, th·ª≠ l·∫°i keyword ƒë√≥
      }

      if (isFirstRun) {
        console.log('‚è≥ L·∫ßn ƒë·∫ßu: ch·ªù 30s ƒë·ªÉ k·∫øt qu·∫£ ·ªïn ƒë·ªãnh...');
        await page.waitForTimeout(30000);
        isFirstRun = false;
      }

      let found = false;

      // --- Duy·ªát qua nhi·ªÅu trang Google ---
      while (!found) {
        const resultLink = page.locator('div#search a[href*="tphomevn"]').first();

        if (await resultLink.count()) {
          const { page: sitePage, isPopup } = await safeClick(page, resultLink, 15000);
          console.log(`üëâ ƒê√£ m·ªü k·∫øt qu·∫£: ${sitePage.url()}`);
          await handleTphomevnPage(sitePage, sitePage.url());

          // N·∫øu m·ªü popup, ƒë√≥ng n√≥ ƒë·ªÉ kh√¥ng r√≤ r·ªâ t√†i nguy√™n
          if (isPopup) {
            await sitePage.close().catch(() => { });
          }
          found = true;
          break;
        }

        // Sang trang ti·∫øp theo n·∫øu ch∆∞a th·∫•y
        const nextBtn = await page.$('#pnnext, a[aria-label="Next"], a[aria-label="Trang ti·∫øp theo"]');
        if (nextBtn) {
          console.log('üëâ Sang trang k·∫øt qu·∫£ k·∫ø ti·∫øp...');
          await Promise.all([
            nextBtn.click(),
            page.waitForNavigation({ waitUntil: 'domcontentloaded', timeout: 15000 }).catch(() => { })
          ]);
          await page.waitForTimeout(2000);
        } else {
          console.log('‚ö†Ô∏è H·∫øt trang t√¨m ki·∫øm m√† kh√¥ng th·∫•y tphomevn.');
          break;
        }
      }

      // chuy·ªÉn sang keyword ti·∫øp theo
      keywordIndex = (keywordIndex + 1) % keywords.length;
      console.log('üîÑ Chuy·ªÉn sang t·ª´ kho√° ti·∫øp theo...');
      await page.waitForTimeout(2000);
    }
  } catch (err) {
    console.error('üí• L·ªói nghi√™m tr·ªçng (ngo√†i v√≤ng):', err);
  } finally {
    isRunning = false;
    // ƒê·ªÉ d·ªÖ debug, kh√¥ng auto-close browser. Khi ch·∫°y th·∫≠t, m·ªü d√≤ng sau:
    // if (browser) await browser.close();
  }
}

runGoogleSearchAndNavigate();
